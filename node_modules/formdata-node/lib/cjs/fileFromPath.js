"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _path, _start;
Object.defineProperty(exports, "__esModule", { value: true });
exports.fileFromPath = exports.fileFromPathSync = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const domexception_1 = __importDefault(require("domexception"));
const File_1 = require("./File");
const isPlainObject_1 = __importDefault(require("./util/isPlainObject"));
const getMimeFromFilename_1 = __importDefault(require("./util/getMimeFromFilename"));
const MESSAGE = "The requested file could not be read, "
    + "typically due to permission problems that have occurred after a reference "
    + "to a file was acquired.";
/**
 * Represends an object referencing a file on a disk
 * Based on [`fetch-blob/from.js`](https://github.com/node-fetch/fetch-blob/blob/a3b0d62b9d88e0fa80af2e36f50ce25222535692/from.js#L32-L72) implementation
 *
 * @api private
 */
class FileFromPath {
    constructor(options) {
        _path.set(this, void 0);
        _start.set(this, void 0);
        __classPrivateFieldSet(this, _path, options.path);
        __classPrivateFieldSet(this, _start, options.start || 0);
        this.name = path_1.basename(__classPrivateFieldGet(this, _path));
        this.size = options.size;
        this.lastModified = options.lastModified;
    }
    slice(start, end) {
        return new FileFromPath({
            path: __classPrivateFieldGet(this, _path),
            lastModified: this.lastModified,
            size: end - start,
            start
        });
    }
    async *stream() {
        const { mtimeMs } = await fs_1.promises.stat(__classPrivateFieldGet(this, _path));
        if (mtimeMs > this.lastModified) {
            // eslint-disable-next-line @typescript-eslint/no-throw-literal
            throw new domexception_1.default(MESSAGE, "NotReadableError");
        }
        if (this.size) {
            yield* fs_1.createReadStream(__classPrivateFieldGet(this, _path), {
                start: __classPrivateFieldGet(this, _start),
                end: __classPrivateFieldGet(this, _start) + this.size - 1
            });
        }
    }
    get [(_path = new WeakMap(), _start = new WeakMap(), Symbol.toStringTag)]() {
        return "File";
    }
}
function createFileFromPath(path, { mtimeMs, size }, filenameOrOptions, options = {}) {
    let filename;
    if (isPlainObject_1.default(filenameOrOptions)) {
        [options, filename] = [filenameOrOptions, undefined];
    }
    else {
        filename = filenameOrOptions;
    }
    const file = new FileFromPath({ path, size, lastModified: mtimeMs });
    if (!filename) {
        filename = file.name;
    }
    if (!options.lastModified) {
        options.lastModified = file.lastModified;
    }
    if (!options.type) {
        options.type = getMimeFromFilename_1.default(filename);
    }
    return new File_1.File([file], filename, options);
}
function fileFromPathSync(path, filenameOrOptions, options = {}) {
    return createFileFromPath(path, fs_1.statSync(path), filenameOrOptions, options);
}
exports.fileFromPathSync = fileFromPathSync;
async function fileFromPath(path, filenameOrOptions, options) {
    const stats = await fs_1.promises.stat(path);
    return createFileFromPath(path, stats, filenameOrOptions, options);
}
exports.fileFromPath = fileFromPath;
