var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _path, _start;
import { statSync, createReadStream, promises as fs } from "fs";
import { basename } from "path";
import DOMException from "domexception";
import { File } from "./File.js";
import isPlainObject from "./util/isPlainObject.js";
import getMime from "./util/getMimeFromFilename.js";
const MESSAGE = "The requested file could not be read, "
    + "typically due to permission problems that have occurred after a reference "
    + "to a file was acquired.";
/**
 * Represends an object referencing a file on a disk
 * Based on [`fetch-blob/from.js`](https://github.com/node-fetch/fetch-blob/blob/a3b0d62b9d88e0fa80af2e36f50ce25222535692/from.js#L32-L72) implementation
 *
 * @api private
 */
class FileFromPath {
    constructor(options) {
        _path.set(this, void 0);
        _start.set(this, void 0);
        __classPrivateFieldSet(this, _path, options.path);
        __classPrivateFieldSet(this, _start, options.start || 0);
        this.name = basename(__classPrivateFieldGet(this, _path));
        this.size = options.size;
        this.lastModified = options.lastModified;
    }
    slice(start, end) {
        return new FileFromPath({
            path: __classPrivateFieldGet(this, _path),
            lastModified: this.lastModified,
            size: end - start,
            start
        });
    }
    async *stream() {
        const { mtimeMs } = await fs.stat(__classPrivateFieldGet(this, _path));
        if (mtimeMs > this.lastModified) {
            // eslint-disable-next-line @typescript-eslint/no-throw-literal
            throw new DOMException(MESSAGE, "NotReadableError");
        }
        if (this.size) {
            yield* createReadStream(__classPrivateFieldGet(this, _path), {
                start: __classPrivateFieldGet(this, _start),
                end: __classPrivateFieldGet(this, _start) + this.size - 1
            });
        }
    }
    get [(_path = new WeakMap(), _start = new WeakMap(), Symbol.toStringTag)]() {
        return "File";
    }
}
function createFileFromPath(path, { mtimeMs, size }, filenameOrOptions, options = {}) {
    let filename;
    if (isPlainObject(filenameOrOptions)) {
        [options, filename] = [filenameOrOptions, undefined];
    }
    else {
        filename = filenameOrOptions;
    }
    const file = new FileFromPath({ path, size, lastModified: mtimeMs });
    if (!filename) {
        filename = file.name;
    }
    if (!options.lastModified) {
        options.lastModified = file.lastModified;
    }
    if (!options.type) {
        options.type = getMime(filename);
    }
    return new File([file], filename, options);
}
export function fileFromPathSync(path, filenameOrOptions, options = {}) {
    return createFileFromPath(path, statSync(path), filenameOrOptions, options);
}
export async function fileFromPath(path, filenameOrOptions, options) {
    const stats = await fs.stat(path);
    return createFileFromPath(path, stats, filenameOrOptions, options);
}
